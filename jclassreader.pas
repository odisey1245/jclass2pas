{ JVM class files specification: http://docs.oracle.com/javase/specs/ }
unit JClassReader;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, bufstream;

const
  { magic }
  JAVA_CLASS_MAGIC = Cardinal($CAFEBABE);

  { constant pool tags }
  CONSTANT_Utf8               = 1;
  CONSTANT_Integer            = 3;
  CONSTANT_Float              = 4;
  CONSTANT_Long               = 5;
  CONSTANT_Double             = 6;
  CONSTANT_Class              = 7;
  CONSTANT_String             = 8;
  CONSTANT_Fieldref           = 9;
  CONSTANT_Methodref          = 10;
  CONSTANT_InterfaceMethodref = 11;
  CONSTANT_NameAndType        = 12;
  CONSTANT_MethodHandle       = 15;
  CONSTANT_MethodType         = 16;
  CONSTANT_InvokeDynamic      = 18;

  { Class/Nested class/Methods access and property modifiers }
  ACC_PUBLIC       = $0001; // Declared public; may be accessed from outside its package
  ACC_PRIVATE      = $0002; // Declared private; accessible only within the defining class
  ACC_PROTECTED    = $0004; // Declared protected; may be accessed within subclasses
  ACC_STATIC       = $0008; // Declared static
  ACC_FINAL        = $0010; // Declared final; must not be overridden
  ACC_SYNCHRONIZED = $0020; // Declared synchronized; invocation is wrapped by a monitor use
  ACC_BRIDGE       = $0040; // A bridge method, generated by the compiler
  ACC_VARARGS      = $0080; // Declared with variable number of arguments
  ACC_NATIVE       = $0100; // Declared native; implemented in a language other than Java
  ACC_INTERFACE    = $0200; // Was an interface in source
  ACC_ABSTRACT     = $0400; // Declared abstract; no implementation is provided
  ACC_STRICT       = $0800; // Declared strictfp; floating-point mode is FP-strict
  ACC_SYNTHETIC    = $1000; // Declared synthetic; not present in the source code
  ACC_ANNOTATION   = $2000; // Declared as an annotation type
  ACC_ENUM         = $4000; // Declared as an enum type

type
  TJavaClassFile = class;

  { TConstPoolEntry }

  TConstPoolEntry = class
  private
    FOwner: TJavaClassFile;
    FTag: Byte;
    data: Pointer;
  public
    constructor Create(utf8str: string);
    constructor Create(tag: Byte; u16: Word);
    constructor Create(tag: Byte; u16_1, u16_2: Word);
    constructor Create(tag: Byte; i32: Integer);
    constructor Create(tag: Byte; i64: Int64);
    constructor Create(tag: Byte; f: Single);
    constructor Create(tag: Byte; d: Double);
    constructor Create(tag: Byte; b: Byte; w: Word);
    destructor Destroy; override;
    function UInt16: Word;
    function Utf8Str: string;
    function AsString: string;
  end;

  TAttributeInfo = record
    attribute_name_index: Word;
    info: TBytes;
  end;

  TFieldInfo = record
    access_flags,
    name_index,
    descriptor_index: Word;
    attributes: array of TAttributeInfo;
  end;

  TMethodInfo = record
    access_flags,
    name_index,
    descriptor_index: Word;
    attributes: array of TAttributeInfo;
  end;

  TInnerClass = record
    inner_class_info_index,
    outer_class_info_index,
    inner_name_index,
    inner_class_access_flags: Word;
  end;

  { TJavaClassFile }

  TJavaClassFile = class
  private
    FSource: TReadBufStream;
    minor_version, major_version: Word;
    access_flags, this_class, super_class: Word;
    FConstantPool: array of TConstPoolEntry; // index 0 not used
    FInterfaces: array of Word; // indexes of ConstantPool
    FFields: array of TFieldInfo;
    FMethods: array of TMethodInfo;
    FAttributes: array of TAttributeInfo;
    FInnerClasses: array of TInnerClass;
    procedure Read;
    procedure ReadConstantPool;
    procedure ReadInterfaces;
    procedure ReadFields;
    procedure ReadMethods;
    procedure ReadAttributes;
    procedure ReadInnerClasses(const attr: TAttributeInfo);
    function ReadFieldInfo: TFieldInfo;
    function ReadAttributeInfo: TAttributeInfo;
    function ReadMethodInfo: TMethodInfo;
    function ReadUInt64: QWord;
    function ReadUInt32: Cardinal;
    function ReadUInt16: Word;
    function ReadUInt8: Byte;
    function ReadInt32: Integer;
    function ReadInt64: Int64;
    function ReadFloat: Single;
    function ReadDouble: Double;
  public
    constructor Create(InputStream: TStream);
    constructor Create(FileName: string);
    destructor Destroy; override;
    function GetAccess: Word;
    function GetClassName: string;
    function GetFieldAccess(Index: Integer): Word;
    function GetFieldConstValue(Index: Integer): string;
    function GetFieldCount: Integer;
    function GetFieldDescriptor(Index: Integer): string;
    function GetFieldName(Index: Integer): string;
    function GetInnerClassesCount: Integer;
    function GetInnerClassName(Index: Integer): string;
    function GetInnerClassOuterClassName(Index: Integer): string;
    function GetInnerClassLocalName(Index: Integer): string;
    function GetInnerClassAccess(Index: Integer): Word;
    function GetInterfacesCount: Integer;
    function GetInterfaceName(Index: Integer): string;
    function GetMethodAccess(Index: Integer): Word;
    function GetMethodCount: Integer;
    function GetMethodDescriptor(Index: Integer): string;
    function GetMethodExceptions(Index: Integer): TStrings;
    function GetMethodName(Index: Integer): string;
    function GetPackage: string;
    function GetSuperClassName: string;
    function IsInterface: Boolean;
  end;

implementation

uses strutils, math;

{ TConstPoolEntry }

constructor TConstPoolEntry.Create(utf8str: string);
var l: Integer;
begin
  FTag := CONSTANT_Utf8;
  l := Length(utf8str);
  GetMem(data, l + 1);
  if l > 0 then
    Move(utf8str[1], data^, l);
  PByte(data)[l] := 0;
end;

constructor TConstPoolEntry.Create(tag: Byte; u16: Word);
begin
  FTag := tag;
  GetMem(data, 2);
  PWord(data)^ := u16;
end;

constructor TConstPoolEntry.Create(tag: Byte; u16_1, u16_2: Word);
begin
  Ftag := tag;
  GetMem(data, 2 * 2);
  PWord(data)[0] := u16_1;
  PWord(data)[1] := u16_2;
end;

constructor TConstPoolEntry.Create(tag: Byte; i32: Integer);
begin
  FTag := tag;
  GetMem(data, 4);
  PInteger(data)^ := i32
end;

constructor TConstPoolEntry.Create(tag: Byte; i64: Int64);
begin
  FTag := tag;
  GetMem(data, 8);
  PInt64(data)^ := i64
end;

constructor TConstPoolEntry.Create(tag: Byte; f: Single);
begin
  FTag := tag;
  GetMem(data, 4);
  PSingle(data)^ := f
end;

constructor TConstPoolEntry.Create(tag: Byte; d: Double);
begin
  FTag := tag;
  GetMem(data, 8);
  PDouble(data)^ := d
end;

constructor TConstPoolEntry.Create(tag: Byte; b: Byte; w: Word);
begin
  FTag := tag;
  GetMem(data, 3);
  PByte(data)^ := b;
  PWord(PByte(data) + 1)^ := w;
end;

destructor TConstPoolEntry.Destroy;
begin
  if Assigned(data) then
    FreeMem(data);
  inherited Destroy;
end;

function TConstPoolEntry.UInt16: Word;
begin
  Result := PWord(data)^
end;

function TConstPoolEntry.Utf8Str: string;
begin
  if FTag <> CONSTANT_Utf8 then
    raise Exception.Create('Constant is not UTF8 string');
  Result := PChar(data);
end;

function TConstPoolEntry.AsString: string;
begin
  case FTag of
    CONSTANT_Utf8: Result := Utf8Str;
    CONSTANT_Long: Result := IntToStr(PInt64(data)^);
    CONSTANT_Float:
      if IsNan(PSingle(data)^) then
        Result := '0.0/0.0'
      else
      if IsInfinite(PSingle(data)^) then
        if PSingle(data)^ < 0 then
          Result := '-1.0/0.0'
        else
          Result := '+1.0/0.0'
      else
        Str(PSingle(data)^, Result);
    CONSTANT_Double:
      if IsNan(PDouble(data)^) then
        Result := '0.0/0.0'
      else
      if IsInfinite(PDouble(data)^) then
        if PSingle(data)^ < 0 then
          Result := '-1.0/0.0'
        else
          Result := '+1.0/0.0'
      else
        Str(PDouble(data)^, Result);
    CONSTANT_Integer: Result := IntToStr(PInteger(data)^);
    CONSTANT_String: Result := PChar(data);
  end;
end;

{ TJavaClassFile }

procedure TJavaClassFile.Read;
var
  magic: Cardinal;
begin
  { magic }
  magic := ReadUInt32;
  if magic <> JAVA_CLASS_MAGIC then
    raise Exception.CreateFmt('Format error: magic = %s (needed %s)',
      [IntToHex(magic, 8), IntToHex(JAVA_CLASS_MAGIC, 8)]);
  { minor_version, major_version }
  minor_version := ReadUInt16;
  major_version := ReadUInt16;
  { constant pool }
  ReadConstantPool;
  access_flags := ReadUInt16;
  this_class := ReadUInt16;
  super_class := ReadUInt16;
  { interfaces }
  ReadInterfaces;
  { fields }
  ReadFields;
  { methods }
  ReadMethods;
  { attributes }
  ReadAttributes;
end;

procedure TJavaClassFile.ReadConstantPool;
var
  i: Integer;
  count: Word;
  tag, b: Byte;
  w1, w2: Word;
  s: string;
begin
  count := ReadUInt16;
  SetLength(FConstantPool, count);
  i := 1;
  while i < count do
  begin
    tag := ReadUInt8;
    case tag of
      CONSTANT_Utf8:
        begin
          w1 := ReadUInt16; // length
          SetLength(s, w1);
          if w1 > 0 then
            FSource.ReadBuffer(s[1], w1);
          FConstantPool[i] := TConstPoolEntry.Create(s);
        end;
      CONSTANT_Integer:
        FConstantPool[i] := TConstPoolEntry.Create(tag, ReadInt32);
      CONSTANT_Float:
        FConstantPool[i] := TConstPoolEntry.Create(tag, ReadFloat);
      CONSTANT_Long:
        FConstantPool[i] := TConstPoolEntry.Create(tag, ReadInt64);
      CONSTANT_Double:
        FConstantPool[i] := TConstPoolEntry.Create(tag, ReadDouble);
      CONSTANT_Class,
      CONSTANT_String:
        FConstantPool[i] := TConstPoolEntry.Create(tag, ReadUInt16);
      CONSTANT_Fieldref,
      CONSTANT_Methodref,
      CONSTANT_InterfaceMethodref:
        begin
          w1 := ReadUInt16; // class_index
          w2 := ReadUInt16; // name_and_type_index
          FConstantPool[i] := TConstPoolEntry.Create(tag, w1, w2);
        end;
      CONSTANT_NameAndType:
        begin
          w1 := ReadUInt16; // name_index
          w2 := ReadUInt16; // descriptor_index
          FConstantPool[i] := TConstPoolEntry.Create(tag, w1, w2);
        end;
      CONSTANT_MethodHandle:
        begin
          b := ReadUInt8;   // reference_kind
          w1 := ReadUInt16; // reference_index
          FConstantPool[i] := TConstPoolEntry.Create(tag, b, w1);
        end;
      CONSTANT_MethodType:
        FConstantPool[i] := TConstPoolEntry.Create(tag, ReadUInt16);
      CONSTANT_InvokeDynamic:
        begin
          w1 := ReadUInt16; // bootstrap_method_attr_index
          w2 := ReadUInt16; // name_and_type_index
          FConstantPool[i] := TConstPoolEntry.Create(tag, w1, w2);
        end;
      else
        raise Exception.CreateFmt('Format error: unknown constant tag %d', [tag]);
    end;
    if tag in [CONSTANT_Long, CONSTANT_Double] then
      Inc(i, 2)
    else
      Inc(i);
  end;
end;

procedure TJavaClassFile.ReadInterfaces;
var
  count: Word;
  i: Integer;
begin
  count := ReadUInt16;
  SetLength(FInterfaces, count);
  for i := 0 to High(FInterfaces) do
    FInterfaces[i] := ReadUInt16;
end;

procedure TJavaClassFile.ReadFields;
var
  count: Word;
  i: Integer;
begin
  count := ReadUInt16;
  SetLength(FFields, count);
  for i := 0 to High(FFields) do
    FFields[i] := ReadFieldInfo;
end;

procedure TJavaClassFile.ReadMethods;
var
  count: Word;
  i: Integer;
begin
  count := ReadUInt16;
  SetLength(FMethods, count);
  for i := 0 to High(FMethods) do
    FMethods[i] := ReadMethodInfo;
end;

procedure TJavaClassFile.ReadAttributes;
var
  count: Word;
  i: Integer;
begin
  count := ReadUInt16;
  SetLength(FAttributes, count);
  for i := 0 to High(FAttributes) do
    FAttributes[i] := ReadAttributeInfo;
end;

procedure TJavaClassFile.ReadInnerClasses(const attr: TAttributeInfo);
var
  i, count: Integer;
begin
  count := attr.info[0] shl 8 or attr.info[1];
  SetLength(FInnerClasses, count);
  for i := 0 to count - 1 do
    with FInnerClasses[i] do
    begin
      inner_class_info_index := attr.info[2 + i * 8] shl 8 or attr.info[3 + i * 8];
      outer_class_info_index := attr.info[4 + i * 8] shl 8 or attr.info[5 + i * 8];
      inner_name_index := attr.info[6 + i * 8] shl 8 or attr.info[7 + i * 8];
      inner_class_access_flags := attr.info[8 + i * 8] shl 8 or attr.info[9 + i * 8];
    end;
end;

function TJavaClassFile.ReadFieldInfo: TFieldInfo;
var
  count: Word;
  i: Integer;
begin
  with Result do
  begin
    access_flags := ReadUInt16;
    name_index := ReadUInt16;
    descriptor_index := ReadUInt16;
    count := ReadUInt16;
    SetLength(attributes, count);
    for i := 0 to High(attributes) do
      attributes[i] := ReadAttributeInfo;
  end;
end;

function TJavaClassFile.ReadAttributeInfo: TAttributeInfo;
var
  len: Cardinal;
  attr_name: string;
begin
  with Result do
  begin
    attribute_name_index := ReadUInt16;
    attr_name := FConstantPool[attribute_name_index].Utf8Str;
    len := ReadUInt32;
    SetLength(info, len);
    if len > 0 then
      FSource.ReadBuffer(info[0], len);
  end;
  if attr_name = 'InnerClasses' then
    ReadInnerClasses(Result);
end;

function TJavaClassFile.ReadMethodInfo: TMethodInfo;
var
  count: Word;
  i: Integer;
begin
  with Result do
  begin
    access_flags := ReadUInt16;
    name_index := ReadUInt16;
    descriptor_index := ReadUInt16;
    count := ReadUInt16;
    SetLength(attributes, count);
    for i := 0 to High(attributes) do
      attributes[i] := ReadAttributeInfo;
  end;
end;

function TJavaClassFile.ReadUInt64: QWord;
var b: Byte; i: Integer;
begin
  Result := 0;
  for i := 1 to 8 do
  begin
    FSource.ReadBuffer(b, 1);
    Result := Result shl 8 or b
  end;
end;

function TJavaClassFile.ReadUInt32: Cardinal;
var b: Byte; i: Integer;
begin
  Result := 0;
  for i := 1 to 4 do
  begin
    FSource.ReadBuffer(b, 1);
    Result := Result shl 8 or b
  end;
end;

function TJavaClassFile.ReadUInt16: Word;
var b: Byte;
begin
  FSource.ReadBuffer(b, 1);
  Result := b shl 8;
  FSource.ReadBuffer(b, 1);
  Result := Result or b;
end;

function TJavaClassFile.ReadUInt8: Byte;
begin
  FSource.ReadBuffer(Result, 1)
end;

function TJavaClassFile.ReadInt32: Integer;
begin
  Result := Integer(ReadUInt32)
end;

function TJavaClassFile.ReadInt64: Int64;
begin
  Result := Int64(ReadUInt64)
end;

function TJavaClassFile.ReadFloat: Single;
var c: Cardinal;
begin
  c := ReadUInt32;
  Result := PSingle(@c)^
end;

function TJavaClassFile.ReadDouble: Double;
var c: QWord;
begin
  c := ReadUInt64;
  Result := PDouble(@c)^
end;

constructor TJavaClassFile.Create(InputStream: TStream);
begin
  FSource := TReadBufStream.Create(InputStream);
  FSource.SourceOwner := True;
  Read;
end;

constructor TJavaClassFile.Create(FileName: string);
begin
  Create(TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite));
end;

destructor TJavaClassFile.Destroy;
var i: Integer;
begin
  for i := 1 to High(FConstantPool) do
    FConstantPool[i].Free;
  FSource.Free;
  inherited Destroy;
end;

function TJavaClassFile.GetAccess: Word;
begin
  Result := access_flags;
end;

function TJavaClassFile.GetMethodCount: Integer;
begin
  Result := Length(FMethods)
end;

function TJavaClassFile.GetInterfacesCount: Integer;
begin
  Result := Length(FInterfaces);
end;

function TJavaClassFile.GetInterfaceName(Index: Integer): string;
var
  c: TConstPoolEntry;
begin
  c := FConstantPool[FInterfaces[Index]];
  if c.FTag <> CONSTANT_Class then
    raise Exception.Create('interface is not class_info index');
  c := FConstantPool[c.UInt16];
  Result := c.Utf8Str;
end;

function TJavaClassFile.GetMethodAccess(Index: Integer): Word;
begin
  Result := FMethods[Index].access_flags
end;

function TJavaClassFile.GetMethodName(Index: Integer): string;
begin
  Result := FConstantPool[FMethods[Index].name_index].Utf8Str
end;

function TJavaClassFile.GetMethodDescriptor(Index: Integer): string;
begin
  Result := FConstantPool[FMethods[Index].descriptor_index].Utf8Str
end;

function TJavaClassFile.GetMethodExceptions(Index: Integer): TStrings;
var
  count: Integer;
  i, j: Integer;
  idx: Word;
  entry: TConstPoolEntry;
begin
  Result := nil;
  with FMethods[Index] do
    for i := 0 to High(attributes) do
      with attributes[i] do
        if FConstantPool[attribute_name_index].Utf8Str = 'Exceptions' then
        begin
          Result := TStringList.Create;
          count := info[0] shl 8 or info[1];
          for j := 0 to count - 1 do
          begin
            idx := info[2 + j * 2] shl 8 or info[3 + j * 2];
            entry := FConstantPool[idx];
            if entry.FTag <> CONSTANT_Class then
              raise Exception.Create('Format error: exception table - not Class info');
            Result.Add(FConstantPool[entry.UInt16].Utf8Str);
          end;
          Exit;
        end;
end;

function TJavaClassFile.GetPackage: string;
var
  i: Integer;
begin
  Result := GetClassName;
  i := RPos('.', Result);
  Result := StringReplace(Copy(Result, 1, i), '/', '.', [rfReplaceAll]);
end;

function TJavaClassFile.GetClassName: string;
var
  c: TConstPoolEntry;
begin
  Result := '';
  if this_class > 0 then
  begin
    c := FConstantPool[this_class];
    if c.FTag = CONSTANT_Class then
    begin
      c := FConstantPool[c.UInt16];
      Result := c.Utf8Str
    end;
  end;
end;

function TJavaClassFile.GetFieldAccess(Index: Integer): Word;
begin
  Result := FFields[Index].access_flags
end;

function TJavaClassFile.GetFieldConstValue(Index: Integer): string;
var
  attr_name: string;
  i: Integer;
  entry: TConstPoolEntry;
begin
  with FFields[Index] do
    for i := 0 to High(attributes) do
    begin
      attr_name := FConstantPool[attributes[i].attribute_name_index].Utf8Str;
      if attr_name = 'ConstantValue' then
      begin
        with attributes[i] do
          entry := FConstantPool[info[0] shl 8 or info[1]];
        if entry.FTag = CONSTANT_String then
          entry := FConstantPool[entry.UInt16];
        Result := entry.AsString;
        Exit
      end;
    end;
end;

function TJavaClassFile.GetFieldCount: Integer;
begin
  Result := Length(FFields)
end;

function TJavaClassFile.GetFieldDescriptor(Index: Integer): string;
begin
  Result := FConstantPool[FFields[Index].descriptor_index].Utf8Str
end;

function TJavaClassFile.GetFieldName(Index: Integer): string;
begin
  Result := FConstantPool[FFields[Index].name_index].Utf8Str
end;

function TJavaClassFile.GetInnerClassesCount: Integer;
begin
  Result := Length(FInnerClasses)
end;

function TJavaClassFile.GetInnerClassName(Index: Integer): string;
var
  c: TConstPoolEntry;
begin
  Result := '';
  c := FConstantPool[FInnerClasses[Index].inner_class_info_index];
  if c.FTag = CONSTANT_Class then
  begin
    c := FConstantPool[c.UInt16];
    Result := c.Utf8Str
  end;
end;

function TJavaClassFile.GetInnerClassOuterClassName(Index: Integer): string;
var
  c: TConstPoolEntry;
begin
  Result := '';
  if FInnerClasses[Index].outer_class_info_index > 0 then
  begin
    c := FConstantPool[FInnerClasses[Index].outer_class_info_index];
    if c.FTag = CONSTANT_Class then
    begin
      c := FConstantPool[c.UInt16];
      Result := c.Utf8Str
    end;
  end;
end;

function TJavaClassFile.GetInnerClassLocalName(Index: Integer): string;
var
  c: TConstPoolEntry;
begin
  Result := '';
  if FInnerClasses[Index].inner_name_index > 0 then
  begin
    c := FConstantPool[FInnerClasses[Index].inner_name_index];
    Result := c.Utf8Str
  end;
end;

function TJavaClassFile.GetInnerClassAccess(Index: Integer): Word;
begin
  Result := FInnerClasses[Index].inner_class_access_flags;
end;

function TJavaClassFile.GetSuperClassName: string;
var
  c: TConstPoolEntry;
begin
  Result := '';
  if super_class > 0 then
  begin
    c := FConstantPool[super_class];
    if c.FTag = CONSTANT_Class then
    begin
      c := FConstantPool[c.UInt16];
      Result := c.Utf8Str
    end;
  end;
end;

function TJavaClassFile.IsInterface: Boolean;
begin
  Result := access_flags and ACC_INTERFACE <> 0
end;

end.

