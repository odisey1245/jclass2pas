unit Translator;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, DeclTypes;

type

  { TTranslateEnv }

  TTranslateEnv = class
  private
    FSingleUnit: Boolean;
    FIncludeFile: Boolean;
    FOutputName: string;
    FAvailableClasses: TStringList; // Objects[] are TClassInFile/TClassInZip
    FClassesToTranslate: TStringList;
    FPackagesToTranslate: TStringList;
    FAccess: TAccessType;
    FZipFiles: TStringList;
    procedure ProcessClassPath(path: string);
    procedure SearchInZipArchive(zipName: string);
  public
    constructor Create;
    destructor Destroy; override;
    procedure ProcessCmdLine;
    function Params: string;
  end;

  { TTranslator }

  TTranslator = class
  private
    FEnv: TTranslateEnv;
    FTranslatedPackages: TStringList;
    FUsedUnits: TStringList;
    FDeclTypes: TDeclTypes;
    function TranslatePackage(PkgName: string): Boolean;
    procedure PrintHeader(fout: TStream);
    procedure SaveDeclTypes(AUnitName: string);
    procedure SaveDeclTypesToHINC;
    procedure SaveDeclTypesToINC;
    procedure SaveDeclTypesToPAS(AunitName: string);
    procedure ClassNotFound(Sender: TObject; JavaClassName: string;
      var Failed: Boolean);
  public
    constructor Create;
    destructor Destroy; override;
    procedure Translate;
  end;

implementation

uses zipper, strutils, JClassReader, MemJarUnzipper;

type

  { TClassInFile }

  TClassInFile = class
  private
    FFileName: string;
    FPackage: string;
    FPackageValid: Boolean;
    FJavaClassFile: TJavaClassFile;
    function GetJavaClass: TJavaClassFile;
  public
    constructor Create(FileName: string);
    destructor Destroy; override;
    function GetClassName: string; virtual;
    function GetStream: TStream; virtual;
    function GetPackage: string;
    property JavaClass: TJavaClassFile read GetJavaClass;
  end;

  { TClassInZip }

  TClassInZip = class(TClassInFile)
  private
    FZip: TMemJarUnzipper;
    FEntry: TFullZipFileEntry;
  public
    constructor Create(zip: TMemJarUnzipper; entry: TFullZipFileEntry);
    function GetClassName: string; override;
    function GetStream: TStream; override;
  end;

{ TTranslator }

procedure TTranslator.ClassNotFound(Sender: TObject; JavaClassName: string;
  var Failed: Boolean);
var
  s: string;
  i: Integer;
begin
  i := Pos('$', JavaClassName);
  if (i > 0) and (JavaClassName[i + 1] in ['0'..'9']) then
  begin
    FDeclTypes.AddFake(JavaClassName);
    Failed := False;
    Exit;
  end;

  s := JavaClassName;
  i := RPos('/', s);
  s := Copy(s, 1, i - 1);
  if not FEnv.FSingleUnit then
  begin
    i := FTranslatedPackages.IndexOfName(s);
    if i >= 0 then
    begin
      FUsedUnits.Add(FTranslatedPackages.ValueFromIndex[i]);
      Failed := False;
    end else begin
      i := FEnv.FAvailableClasses.IndexOf(JavaClassName);
      if i >= 0 then
      begin
        FDeclTypes.Add(TClassInFile(FEnv.FAvailableClasses.Objects[i]).JavaClass);
        Failed := False;
      end;
    end;
  end else begin
    i := FEnv.FAvailableClasses.IndexOf(JavaClassName);
    if i >= 0 then
    begin
      FDeclTypes.Add(TClassInFile(FEnv.FAvailableClasses.Objects[i]).JavaClass);
      Failed := False;
    end;
  end;
end;

function TTranslator.TranslatePackage(PkgName: string): Boolean;
var
  i: Integer;
  cls: TClassInFile;
  s: string;
begin
  try
    with FEnv.FAvailableClasses do
      for i := 0 to Count - 1 do
      begin
        cls := TClassInFile(Objects[i]);
        if cls.GetPackage = PkgName then
        begin
          s := cls.JavaClass.GetClassName;
          if (Pos('$', s) = 0) and (FDeclTypes.Find(s, False) = nil) then
            FDeclTypes.Add(cls.JavaClass)
        end;
      end;
    Result := True;
  except
    Result := False;
  end;
end;

procedure TTranslator.PrintHeader(fout: TStream);
var s: string;
begin
  s := '{* automatically generated by' + sLineBreak
      + ' * ' + ExtractFileName(ParamStr(0)) + ' ' + FEnv.Params + sLineBreak
      + ' *}' + sLineBreak + sLineBreak;
  fout.WriteBuffer(s[1], Length(s));
end;

procedure TTranslator.SaveDeclTypes(AUnitName: string);
begin
  if FEnv.FIncludeFile then
  begin
    SaveDeclTypesToHINC;
    SaveDeclTypesToINC;
  end else
    SaveDeclTypesToPAS(AUnitName);
end;

procedure TTranslator.SaveDeclTypesToHINC;
var
  fout: TFileStream;
  s: string;
begin
  { forward class declarations + array types }
  fout := TFileStream.Create(FEnv.FOutputName + 'h.inc', fmCreate);
  try
    PrintHeader(fout);
    s := 'type' + sLineBreak;
    fout.WriteBuffer(s[1], Length(s));
    FDeclTypes.PrintAllPredeclarations(fout);
    FDeclTypes.PrintArrays(fout);
  finally
    fout.Free;
  end;
end;

procedure TTranslator.SaveDeclTypesToINC;
var
  fout: TFileStream;
begin
  { class delarations with methods }
  fout := TFileStream.Create(FEnv.FOutputName + '.inc', fmCreate);
  try
    PrintHeader(fout);
    FDeclTypes.PrintDeclarationsInheritanceOrder(fout, FEnv.FAccess);
  finally
    fout.Free;
  end;
end;

procedure TTranslator.SaveDeclTypesToPAS(AunitName: string);
var
  fout: TStream;

  procedure PrintLn(str: string);
  begin
    str := str + sLineBreak;
    fout.Write(str[1], Length(str));
  end;

var
  s, ext: string;
  i: Integer;
begin
  { complete unit }
  if FEnv.FOutputName <> '' then
    s := FEnv.FOutputName
  else
    s := AunitName;
  ext := ExtractFileExt(s);
  if not (SameText(ext, '.pp') or SameText(ext, '.pas') or SameText(ext, '.p')) then
    s := s + '.pas';
  AunitName := ExtractFileName(s);
  i := RPos('.', AunitName);
  AunitName := Copy(AunitName, 1, i - 1);
  fout := TFileStream.Create(s, fmCreate);
  try
    PrintHeader(fout);
    PrintLn('unit ' + AunitName + ';');
    PrintLn('');
    PrintLn('{$mode objfpc}');
    PrintLn('');
    PrintLn('interface');
    PrintLn('');
    if FUsedUnits.Count > 0 then
    begin
      PrintLn('uses');
      s := '  ' + FUsedUnits[0];
      for i := 1 to FUsedUnits.Count - 1 do
      begin
        ext := FUsedUnits[i];
        if Length(s) + Length(ext) + 2 > 80 then
        begin
          PrintLn(s + ',');
          s := '  ' + ext;
        end else
          s := s + ', ' + ext;
      end;
      PrintLn(s + ';');
      PrintLn('');
    end;
    PrintLn('type');
    { classes declarations }
    FDeclTypes.PrintNeededPredeclarations(fout);
    FDeclTypes.PrintArrays(fout);
    FDeclTypes.PrintDeclarations(fout, FEnv.FAccess);
    PrintLn('interface');
    PrintLn('');
    PrintLn('end.');
  finally
    fout.Free;
  end;
end;

constructor TTranslator.Create;
begin
  FEnv := TTranslateEnv.Create;
  FEnv.ProcessCmdLine;
  FTranslatedPackages := TStringList.Create;
  FDeclTypes := TDeclTypes.Create;
  FDeclTypes.OnClassNotFound := @ClassNotFound;
  FUsedUnits := TStringList.Create;
end;

destructor TTranslator.Destroy;
begin
  FUsedUnits.Free;
  FDeclTypes.Free;
  FEnv.Free;
  FTranslatedPackages.Free;
  inherited Destroy;
end;

procedure TTranslator.Translate;
var
  i: Integer;
  done: Boolean;
  s: string;
begin
  FDeclTypes.Clear;
  while FEnv.FPackagesToTranslate.Count > 0 do
  begin
    done := False;
    for i := FEnv.FPackagesToTranslate.Count - 1 downto 0 do
    begin
      s := FEnv.FPackagesToTranslate[i];
      if TranslatePackage(s) then
      begin
        done := True;
        if not FEnv.FSingleUnit then
        begin
          SaveDeclTypes(Copy(s, 1, Length(s) - 1));
          FTranslatedPackages.Add(s);
          FDeclTypes.Clear;
        end;
        FEnv.FPackagesToTranslate.Delete(i);
      end;
    end;
    if not done then
      raise Exception.Create('cannot translate: package circular dependencies?')
  end;
  while FEnv.FClassesToTranslate.Count > 0 do
  begin
    s := FEnv.FClassesToTranslate[0];
    FEnv.FClassesToTranslate.Delete(0);
    if FTranslatedPackages.IndexOf(Copy(s, 1, RPos('.', s))) >= 0 then Continue;
    s := StringReplace(s, '.', '/', [rfReplaceAll]);
    FDeclTypes.Find(s, True);
    if not FEnv.FSingleUnit then
    begin
      SaveDeclTypes(StringReplace(s, '/', '.', [rfReplaceAll]) + '.pas');
      FDeclTypes.Clear;
    end;
  end;
  if FEnv.FSingleUnit then
    SaveDeclTypes(FEnv.FOutputName)
end;

{ TClassInFile }

function TClassInFile.GetJavaClass: TJavaClassFile;
begin
  if FJavaClassFile = nil then
    FJavaClassFile := TJavaClassFile.Create(GetStream);
  Result := FJavaClassFile;
end;

constructor TClassInFile.Create(FileName: string);
begin
  FFileName := FileName;
end;

destructor TClassInFile.Destroy;
begin
  FJavaClassFile.Free;
  inherited Destroy;
end;

function TClassInFile.GetClassName: string;
begin
  Result := ExtractFileName(FFileName);
  Result := Copy(Result, 1, Length(Result) - 6); // delete ".class"
end;

function TClassInFile.GetStream: TStream;
begin
  Result := TFileStream.Create(FFileName, fmOpenRead or fmShareDenyWrite)
end;

function TClassInFile.GetPackage: string;
begin
  if FPackageValid then
    Result := FPackage
  else begin
    if not Assigned(FJavaClassFile) then
      FJavaClassFile := TJavaClassFile.Create(GetStream);
    FPackage := FJavaClassFile.GetPackage;
    FPackageValid := True;
  end;
end;

{ TClassInZip }

constructor TClassInZip.Create(zip: TMemJarUnzipper; entry: TFullZipFileEntry);
begin
  FZip := zip;
  FFileName := zip.FileName;
  FEntry := entry;
  // assumption: path in JAR is correct package
  if SameText(ExtractFileExt(FFileName), '.jar') then
  begin
    FPackage := ExtractFilePath(entry.ArchiveFileName);
    FPackage := StringReplace(FPackage, '/', '.', [rfReplaceAll]);
    FPackageValid := True;
  end;
end;

function TClassInZip.GetClassName: string;
begin
  Result := ExtractFileName(FEntry.ArchiveFileName);
  Result := Copy(Result, 1, Length(Result) - 6); // delete ".class"
end;

function TClassInZip.GetStream: TStream;
begin
  FZip.Unzip(FEntry);
  Result := FEntry.Stream;
end;

{ TTranslateEnv }

procedure TTranslateEnv.ProcessClassPath(path: string);
var
  i: Integer;
  p, ext: string;
  sr: TSearchRec;
  cls: TClassInFile;
begin
  path := Trim(path);
  if path = '' then Exit;
  // TODO: check it in Linux, Windows removes double quotes automatically
  //if (path[1] = '"') and (path[Length(path)] = '"') then
  //  path := Copy(path, 2, Length(path) - 2);
  path := path + ';';
  i := Pos(';', path);
  while i > 0 do
  begin
    p := Copy(path, 1, i - 1);
    Delete(path, 1, i);
    if FindFirst(p, faAnyFile and not faDirectory, sr) = 0 then
      repeat
        ext := ExtractFileExt(sr.Name);
        if SameText(ext, '.zip') or SameText(ext, '.jar') then
          SearchInZipArchive(ExtractFilePath(p) + sr.Name)
        else
        if SameText(ext, '.class') then
        begin
          cls := TClassInFile.Create(ExtractFilePath(p) + sr.Name);
          FAvailableClasses.AddObject(cls.GetClassName, cls);
        end;
      until FindNext(sr) <> 0;
    FindClose(sr);
    i := Pos(';', path);
  end;
end;

procedure TTranslateEnv.SearchInZipArchive(zipName: string);
var
  ext, c: string;
  zip: TMemJarUnzipper;
  entry: TFullZipFileEntry;
  i: Integer;
begin
  zip := TMemJarUnzipper.Create;
  zip.FileName := zipName;
  FZipFiles.AddObject(zipName, zip);
  for i := 0 to zip.Entries.Count - 1 do
  begin
    entry := zip.Entries[i];
    ext := ExtractFileExt(entry.ArchiveFileName);
    if SameText(ext, '.class') then
    begin
      c := entry.ArchiveFileName;
      c := Copy(c, 1, Length(c) - 6); // delete ".class"
      FAvailableClasses.AddObject(c, TClassInZip.Create(zip, entry));
    end;
  end;
end;

constructor TTranslateEnv.Create;
begin
  FAvailableClasses := TStringList.Create;
  FAvailableClasses.Sorted := True;
  FAvailableClasses.Duplicates := dupAccept;
  FAvailableClasses.OwnsObjects := True;
  FClassesToTranslate := TStringList.Create;
  FClassesToTranslate.Sorted := True;
  FClassesToTranslate.Duplicates := dupIgnore;
  FPackagesToTranslate := TStringList.Create;
  FPackagesToTranslate.Sorted := True;
  FPackagesToTranslate.Duplicates := dupIgnore;
  FZipFiles := TStringList.Create;
  FZipFiles.OwnsObjects := True;
end;

destructor TTranslateEnv.Destroy;
begin
  FZipFiles.Free;
  FAvailableClasses.Free;
  FClassesToTranslate.Free;
  FPackagesToTranslate.Free;
  inherited Destroy;
end;

function TTranslateEnv.Params: string;
var
  i: Integer;
  s: string;
begin
  Result := '';
  for i := 1 to ParamCount do
  begin
    s := ParamStr(i);
    if Pos(' ', s) > 0 then s := '"' + s + '"';
    if Result <> '' then
      Result := Result + ' ';
    Result := Result + s;
  end;
end;

procedure TTranslateEnv.ProcessCmdLine;
var
  pc: Integer;
  pn: string;
  i, j: Integer;
begin
  i := 1;
  pc := ParamCount;
  while i <= pc do
  begin
    pn := ParamStr(i);
    if (Length(pn) > 1) and (pn[1] = '-') then
      case pn[2] of
        'i': if pn = '-i' then FIncludeFile := True;
        'o':
          if (pn = '-o') and (i < pc) then
          begin
            Inc(i);
            FOutputName := ParamStr(i);
            FSingleUnit := True;
          end;
        'p':
          if pn = '-public' then FAccess := acPublic else
          if pn = '-protected' then FAccess := acProtected else
          if pn = '-private' then FAccess := acPrivate;
        'c':
          if (pn = '-classpath') and (i < pc) then
          begin
            Inc(i);
            ProcessClassPath(ParamStr(i))
          end;
      end
    else begin
      if (pn <> '') and (pn[Length(pn)] = '.') then
        FPackagesToTranslate.Add(pn)
      else
        FClassesToTranslate.Add(pn)
    end;
    Inc(i);
  end;
  // remove classes that are in packages to translate
  if FPackagesToTranslate.Count > 0 then
    for i := FClassesToTranslate.Count - 1 downto 0 do
    begin
      pn := FClassesToTranslate[i];
      j := RPos('.', pn);
      if FPackagesToTranslate.IndexOf(Copy(pn, 1, j)) >= 0 then
        FClassesToTranslate.Delete(i)
    end;
  {$ifdef DEBUG}
  WriteLn('available classes: ', FAvailableClasses.Count);
  {$endif}
end;

end.

